<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Đình Hường ♥ Khánh Linh</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; overflow: hidden; background: #000; touch-action: none; 
            height: 100vh; width: 100vw;
            padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) 0;
        }
        #overlay {
            position: absolute; top: 80%; width: 100%;
            text-align: center; color: #ffb6c1; 
            font-family: 'Great Vibes', cursive; letter-spacing: 1px;
            pointer-events: none; font-size: 18px;
            animation: blink 2.5s infinite; z-index: 100;
        }
        @keyframes blink { 0%, 100% { opacity: 0.2; } 50% { opacity: 0.9; } }
    </style>
</head>
<body>
    <div id="overlay">Chạm để mở lời yêu thương...</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        camera.position.z = 25; 

        const messages = [
            ["Đình Hường", "♥", "Khánh Linh"],
            ["From", "13.05.2023"],
            ["Today", "1000 ngày yêu"],
            ["Happy", "Valentine's Day"],
            ["Love you", "Forever"],
            ["14.02.2026"]
        ];
        let currentMsgIndex = -1;
        let state = "INTRO"; 
        
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(0.1, 0.1, 0.2, 0, 0, -0.2);
        heartShape.bezierCurveTo(-0.2, 0, -0.1, 0.1, 0, 0);
        const miniHeartGeo = new THREE.ShapeGeometry(heartShape);

        // Trái tim khởi đầu
        const countHeart = 9500;
        const heartMesh = new THREE.InstancedMesh(miniHeartGeo, new THREE.MeshBasicMaterial({ 
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide 
        }), countHeart);
        scene.add(heartMesh);

        // Chữ hội tụ (Trắng viền hồng)
        const countText = 13000; 
        const textMesh = new THREE.InstancedMesh(miniHeartGeo, new THREE.MeshBasicMaterial({ 
            transparent: false, // Giữ opacity 100%
            side: THREE.DoubleSide 
        }), countText);
        textMesh.visible = false;
        scene.add(textMesh);

        const dummy = new THREE.Object3D();
        const heartPos = [], heartTarget = [], heartColors = [], explodeVels = [];
        const textCurrentPos = [], textTargetPos = [], textColors = [];

        function isInsideHeart(x, y, z) {
            const x2 = x * x, y2 = y * y, z2 = z * z;
            return Math.pow(x2 + 2.25*y2 + z2 - 1, 3) - x2*z2*z - 0.1125*y2*z2*z <= 0;
        }

        for (let i = 0; i < countHeart; i++) {
            let pt = new THREE.Vector3();
            do { pt.set((Math.random()-0.5)*3.5, (Math.random()-0.5)*3.5, (Math.random()-0.5)*3.5); } while (!isInsideHeart(pt.x, pt.y, pt.z));
            const target = new THREE.Vector3(pt.x * 3.8, pt.z * 3.8, -pt.y * 3.8);
            heartTarget.push(target);
            heartPos.push(new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*80, (Math.random()-0.5)*40));
            heartColors.push(new THREE.Color().setHSL(0.02, 0.8, 0.6));
            explodeVels.push(target.clone().normalize().multiplyScalar(Math.random() * 1.5 + 1.0));
        }

        for (let i = 0; i < countText; i++) {
            textCurrentPos.push(new THREE.Vector3(0, 0, 0));
            textTargetPos.push(new THREE.Vector3(0, 0, 0));
            // Tạo hiệu ứng viền hồng: 80% trắng, 20% hồng nhạt
            const color = Math.random() > 0.8 ? new THREE.Color(0xff69b4) : new THREE.Color(0xffffff);
            textColors.push(color);
        }

        function getTextPoints(lines) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1200; canvas.height = 1200;
            ctx.fillStyle = 'white';
            ctx.font = '85px "Great Vibes"';
            ctx.textAlign = 'center';
            lines.forEach((line, index) => {
                const yOffset = 600 + (index - (lines.length - 1) / 2) * 125;
                ctx.fillText(line, 600, yOffset);
            });
            const data = ctx.getImageData(0, 0, 1200, 1200).data;
            const pts = [];
            const scaleFactor = 0.024; 
            for (let y = 0; y < 1200; y += 2) {
                for (let x = 0; x < 1200; x += 2) {
                    if (data[(y * 1200 + x) * 4 + 3] > 140) {
                        pts.push(new THREE.Vector3((x - 600) * scaleFactor, -(y - 600) * scaleFactor, 3)); 
                    }
                }
            }
            return pts;
        }

        function nextMessage() {
            currentMsgIndex++;
            if (currentMsgIndex < messages.length) {
                const pts = getTextPoints(messages[currentMsgIndex]);
                for (let i = 0; i < countText; i++) {
                    const target = pts[i % pts.length] || new THREE.Vector3(0, -100, 0);
                    textTargetPos[i].copy(target);
                    textCurrentPos[i].set((Math.random()-0.5)*40, (Math.random()-0.5)*60, (Math.random()-0.5)*30);
                }
                setTimeout(nextMessage, 5500);
            }
        }

        const fireworks = [];
        
        // Pháo nổ quầng sáng Trắng/Vàng
        function createRealFirework() {
            const color = new THREE.Color(0xffffff);
            const pCount = 120;
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(pCount * 3);
            const vels = [];
            const origin = new THREE.Vector3((Math.random()-0.5)*18, Math.random()*12, -8);
            for(let i=0; i<pCount; i++) {
                posArr[i*3]=origin.x; posArr[i*3+1]=origin.y; posArr[i*3+2]=origin.z;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = Math.random() * 0.2 + 0.1;
                vels.push(new THREE.Vector3(Math.sin(phi)*Math.cos(theta)*speed, Math.sin(phi)*Math.sin(theta)*speed, Math.cos(phi)*speed));
            }
            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            const points = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.08, color: color, transparent: true, blending: THREE.AdditiveBlending }));
            scene.add(points);
            fireworks.push({ points, vels, life: 1.2 });
        }

        // Pháo HÌNH TRÁI TIM MÀU HỒNG
        function createHeartFirework() {
            const pCount = 100;
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(pCount * 3);
            const vels = [];
            const centerX = (Math.random() - 0.5) * 14;
            const centerY = Math.random() * 8 + 6;
            const centerZ = -12;
            for(let i=0; i<pCount; i++) {
                posArr[i*3] = centerX; posArr[i*3+1] = centerY; posArr[i*3+2] = centerZ;
                const t = Math.random() * Math.PI * 2;
                const vx = 16 * Math.pow(Math.sin(t), 3);
                const vy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                vels.push(new THREE.Vector3(vx * 0.02, vy * 0.02, (Math.random()-0.5)*0.05));
            }
            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            const points = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.12, 
                color: new THREE.Color(0xff69b4), // MÀU HỒNG RỰC RỠ
                transparent: true, 
                blending: THREE.AdditiveBlending 
            }));
            scene.add(points);
            fireworks.push({ points, vels, life: 1.8 });
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            
            if (state === "INTRO") {
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 22, 0.03);
                if (camera.position.z < 22.1) state = "WAIT";
            }

            const isPlaying = (state === "PLAYING" || state === "EXPLODE");
            const bgOpacity = (state === "PLAYING") ? 0.2 : 1.0;

            heartMesh.rotation.y += (state === "PLAYING") ? 0.001 : 0.007;
            for (let i = 0; i < countHeart; i++) {
                if (state === "WAIT" || state === "INTRO") {
                    heartPos[i].lerp(heartTarget[i], 0.05);
                } else if (state === "EXPLODE") {
                    heartPos[i].add(explodeVels[i]);
                }
                dummy.position.copy(heartPos[i]);
                const s = (state === "PLAYING" ? 0.1 : 0.35) + Math.sin(t * 3 + i) * 0.03;
                dummy.scale.set(s, s, s);
                dummy.lookAt(camera.position);
                dummy.updateMatrix();
                heartMesh.setMatrixAt(i, dummy.matrix);
                heartMesh.setColorAt(i, heartColors[i].clone().multiplyScalar(bgOpacity));
            }
            heartMesh.instanceMatrix.needsUpdate = true;
            heartMesh.instanceColor.needsUpdate = true;

            if (state === "PLAYING") {
                textMesh.visible = true;
                for (let i = 0; i < countText; i++) {
                    textCurrentPos[i].lerp(textTargetPos[i], 0.07);
                    dummy.position.copy(textCurrentPos[i]);
                    dummy.scale.set(0.1, 0.1, 0.1); 
                    dummy.lookAt(camera.position);
                    dummy.updateMatrix();
                    textMesh.setMatrixAt(i, dummy.matrix);
                    textMesh.setColorAt(i, textColors[i]); // Chữ Trắng - Viền Hồng
                }
                textMesh.instanceMatrix.needsUpdate = true;
                textMesh.instanceColor.needsUpdate = true;
                
                if (Math.random() < 0.04) createRealFirework(); 
                if (Math.random() < 0.06) createHeartFirework(); // Bắn pháo tim hồng
            }

            for (let i = fireworks.length - 1; i >= 0; i--) {
                const f = fireworks[i];
                const pAttr = f.points.geometry.attributes.position;
                for (let j = 0; j < f.vels.length; j++) {
                    pAttr.setX(j, pAttr.getX(j) + f.vels[j].x);
                    pAttr.setY(j, pAttr.getY(j) + f.vels[j].y);
                    pAttr.setZ(j, pAttr.getZ(j) + f.vels[j].z);
                    f.vels[j].y -= 0.003; 
                    f.vels[j].multiplyScalar(0.985);
                }
                pAttr.needsUpdate = true;
                f.life -= 0.01;
                f.points.material.opacity = f.life;
                if (f.life <= 0) { scene.remove(f.points); fireworks.splice(i, 1); }
            }
            renderer.render(scene, camera);
        }

        function startApp() {
            if (state === "WAIT" || state === "INTRO") {
                state = "EXPLODE";
                document.getElementById('overlay').style.display = 'none';
                setTimeout(() => {
                    state = "PLAYING";
                    nextMessage();
                }, 850);
            }
        }

        window.addEventListener('mousedown', startApp);
        window.addEventListener('touchstart', (e) => { e.preventDefault(); startApp(); }, { passive: false });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>