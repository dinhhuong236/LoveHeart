<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Đình Hường & Khánh Linh</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        #overlay {
            position: absolute; bottom: 8%; width: 100%;
            text-align: center; color: #ffb6c1;
            font-family: sans-serif; letter-spacing: 2px;
            pointer-events: none; font-size: 10px; opacity: 0.8;
            animation: blink 2s infinite;
        }
        @keyframes blink { 0%, 100% { opacity: 0.3; } 50% { opacity: 0.8; } }
    </style>
</head>
<body>
    <div id="overlay">CHẠM VÀO TRÁI TIM ĐỂ BẮT ĐẦU</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 15;

        const messages = [
            "Đình Hường <3 Khánh Linh",
            "13.05.2023",
            "1000 days",
            "Happy valentine day",
            "Love you forever"
        ];
        let currentMsgIndex = -1;
        let state = "HEART"; 
        const count = 9000; 

        // --- MINI HEART GEOMETRY ---
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(0.1, 0.1, 0.2, 0, 0, -0.2);
        heartShape.bezierCurveTo(-0.2, 0, -0.1, 0.1, 0, 0);
        const miniHeartGeo = new THREE.ShapeGeometry(heartShape);

        const iMesh = new THREE.InstancedMesh(miniHeartGeo, new THREE.MeshBasicMaterial({ 
            transparent: true, blending: THREE.AdditiveBlending, side: THREE.DoubleSide 
        }), count);
        scene.add(iMesh);

        const dummy = new THREE.Object3D();
        const positions = [];
        const heartTargetPositions = [];
        const colors = [];

        function isInsideHeart(x, y, z) {
            const x2 = x * x, y2 = y * y, z2 = z * z;
            return Math.pow(x2 + (2.25)*y2 + z2 - 1, 3) - x2*z2*z - (0.1125)*y2*z2*z <= 0;
        }

        let found = 0;
        while (found < count) {
            const x = (Math.random() - 0.5) * 3.5;
            const y = (Math.random() - 0.5) * 3.5;
            const z = (Math.random() - 0.5) * 3.5;
            if (isInsideHeart(x, y, z)) {
                heartTargetPositions.push(new THREE.Vector3(x * 4, z * 4, -y * 4));
                positions.push(new THREE.Vector3((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40));
                colors.push(new THREE.Color().setHSL(Math.random() * 0.1 + 0.95, 0.8, 0.8));
                found++;
            }
        }

        function getTextPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1200; canvas.height = 400;
            ctx.fillStyle = 'white';
            ctx.font = '75px "Great Vibes"';
            ctx.textAlign = 'center';
            ctx.fillText(text, 600, 200);
            const data = ctx.getImageData(0, 0, 1200, 400).data;
            const pts = [];
            for (let y = 0; y < 400; y += 4) {
                for (let x = 0; x < 1200; x += 4) {
                    if (data[(y * 1200 + x) * 4 + 3] > 128) {
                        pts.push(new THREE.Vector3((x - 600) * 0.022, -(y - 200) * 0.022, 0));
                    }
                }
            }
            return pts;
        }

        let currentTextPts = [];

        // --- FIREWORKS (Tạo background trái tim khi nổ) ---
        const fwGroup = new THREE.Group();
        scene.add(fwGroup);
        let fireworks = [];
        function createFirework() {
            const pCount = 40;
            const fGeo = new THREE.BufferGeometry();
            const fPos = new Float32Array(pCount * 3);
            const vels = [];
            // Bắn từ dưới lên
            const origin = new THREE.Vector3((Math.random()-0.5)*12, -15, (Math.random()-0.5)*5);
            for(let i=0; i<pCount; i++) {
                fPos[i*3]=origin.x; fPos[i*3+1]=origin.y; fPos[i*3+2]=origin.z;
                vels.push(new THREE.Vector3((Math.random()-0.5)*0.15, Math.random()*0.3 + 0.2, (Math.random()-0.5)*0.1));
            }
            fGeo.setAttribute('position', new THREE.BufferAttribute(fPos, 3));
            const color = new THREE.Color().setHSL(Math.random(), 0.8, 0.6);
            const fMat = new THREE.PointsMaterial({ size: 0.15, color: color, transparent: true, blending: THREE.AdditiveBlending });
            const p = new THREE.Points(fGeo, fMat);
            fwGroup.add(p);
            fireworks.push({ p, vels, life: 1.5, type: Math.random() > 0.5 ? 'heart' : 'spark' });
        }

        function nextMessage() {
            currentMsgIndex++;
            if (currentMsgIndex < messages.length) {
                currentTextPts = getTextPoints(messages[currentMsgIndex]);
                setTimeout(nextMessage, 4500); 
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            const jitter = Math.sin(t * 8) * 0.015;

            for (let i = 0; i < count; i++) {
                let target = new THREE.Vector3();
                if (state === "HEART") {
                    target.copy(heartTargetPositions[i]);
                    iMesh.rotation.y += 0.00005; // XOAY RẤT CHẬM (Tốc độ giảm 10 lần)
                } else if (state === "EXPLODE") {
                    target.copy(positions[i]).multiplyScalar(1.2); 
                } else if (state === "TEXT") {
                    const pt = currentTextPts[i % currentTextPts.length];
                    target.set(pt.x + jitter, pt.y + jitter, pt.z);
                    iMesh.rotation.y *= 0.95;
                    iMesh.material.opacity = 0.6; // Opacity 50-60% cho chữ
                }

                positions[i].lerp(target, state === "EXPLODE" ? 0.15 : 0.04);
                dummy.position.copy(positions[i]);
                const s = (state === "TEXT" ? 0.3 : 0.45) + Math.sin(t * 3 + i) * 0.1;
                dummy.scale.set(s, s, s);
                dummy.lookAt(camera.position);
                dummy.updateMatrix();
                iMesh.setMatrixAt(i, dummy.matrix);
            }

            iMesh.instanceMatrix.needsUpdate = true;

            // Update Pháo hoa background
            if (Math.random() < 0.04) createFirework();
            fireworks.forEach((f, idx) => {
                const attr = f.p.geometry.attributes.position;
                for(let i=0; i<40; i++) {
                    attr.setXYZ(i, attr.getX(i)+f.vels[i].x, attr.getY(i)+f.vels[i].y, attr.getZ(i)+f.vels[i].z);
                    f.vels[i].y -= 0.002; // Gravity
                }
                attr.needsUpdate = true;
                f.life -= 0.01; f.p.material.opacity = f.life;
                if(f.life <= 0) { fwGroup.remove(f.p); fireworks.splice(idx, 1); }
            });

            renderer.render(scene, camera);
        }

        // --- FULLSCREEN & ORIENTATION ---
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => {});
            }
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Tự động vào fullscreen khi xoay ngang trên một số trình duyệt hỗ trợ
            if (window.innerHeight < window.innerWidth) {
                toggleFullScreen();
            }
        });

        // --- SỰ KIỆN CLICK ---
        window.addEventListener('pointerdown', () => {
            toggleFullScreen(); // Vào fullscreen khi bắt đầu tương tác
            if (state === "HEART") {
                state = "EXPLODE";
                document.getElementById('overlay').style.display = 'none';
                setTimeout(() => {
                    state = "TEXT";
                    nextMessage();
                }, 800);
            }
        });

        animate();
    </script>
</body>
</html>