<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Đình Hường & Khánh Linh</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        canvas { display: block; }
        #overlay {
            position: absolute; bottom: 10%; width: 100%;
            text-align: center; color: rgba(255,192,203,0.8);
            font-family: sans-serif; letter-spacing: 3px;
            pointer-events: none; text-transform: uppercase; font-size: 10px;
        }
    </style>
</head>
<body>
    <div id="overlay">Chạm vào trái tim</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 15;

        let state = "HEART"; 
        const clock = new THREE.Clock();

        // --- SHAPE GENERATORS ---
        // Phương trình trái tim 3D bo cong (Taubin's Heart Surface)
        function isInsideHeart(x, y, z) {
            const x2 = x * x, y2 = y * y, z2 = z * z;
            return Math.pow(x2 + (9/4)*y2 + z2 - 1, 3) - x2*z2*z - (9/80)*y2*z2*z <= 0;
        }

        // Tạo hình dáng Trái tim nhỏ (geometry cho từng hạt)
        const heartShape = new THREE.Shape();
        heartShape.moveTo(0, 0);
        heartShape.bezierCurveTo(0.1, 0.1, 0.2, 0, 0, -0.2);
        heartShape.bezierCurveTo(-0.2, 0, -0.1, 0.1, 0, 0);
        const miniHeartGeo = new THREE.ShapeGeometry(heartShape);

        // --- PARTICLES SETUP ---
        const count = 6000; // Số lượng trái tim nhỏ
        const iMesh = new THREE.InstancedMesh(miniHeartGeo, new THREE.MeshBasicMaterial({ 
            side: THREE.DoubleSide, 
            transparent: true,
            blending: THREE.AdditiveBlending 
        }), count);

        const dummy = new THREE.Object3D();
        const positions = [];
        const targetPositions = [];
        const colors = [];
        const textPositions = [];

        // Khởi tạo vị trí Trái tim 3D (Đặc ruột)
        let found = 0;
        while (found < count) {
            const x = (Math.random() - 0.5) * 3;
            const y = (Math.random() - 0.5) * 3;
            const z = (Math.random() - 0.5) * 3;
            
            if (isInsideHeart(x, y, z)) {
                // Tỉ lệ scale cho iPhone
                const scale = 4.5;
                targetPositions.push(new THREE.Vector3(x * scale, z * scale, -y * scale)); // Hoán đổi y-z để đứng
                
                // Vị trí ban đầu hỗn loạn
                positions.push(new THREE.Vector3((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20));
                
                // Màu sắc sặc sỡ hồng/trắng
                const col = new THREE.Color().setHSL(Math.random() * 0.1 + 0.9, 0.8, Math.random() * 0.3 + 0.7);
                colors.push(col);
                found++;
            }
        }

        // --- TEXT GENERATION ---
        function generateTextPositions() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800; canvas.height = 400;
            ctx.fillStyle = 'white';
            ctx.font = '60px "Great Vibes"';
            ctx.textAlign = 'center';
            ctx.fillText('Đình Hường <3 Khánh Linh', 400, 200);
            
            const data = ctx.getImageData(0, 0, 800, 400).data;
            const points = [];
            for (let y = 0; y < 400; y += 5) {
                for (let x = 0; x < 800; x += 5) {
                    if (data[(y * 800 + x) * 4 + 3] > 128) {
                        points.push(new THREE.Vector3((x - 400) * 0.025, -(y - 200) * 0.025, 0));
                    }
                }
            }
            return points;
        }
        const textPts = generateTextPositions();

        scene.add(iMesh);

        // --- FIREWORKS ---
        const fwGroup = new THREE.Group();
        scene.add(fwGroup);
        function createFirework() {
            const pCount = 30;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(pCount * 3);
            const vels = [];
            const origin = new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*15, -5);
            for(let i=0; i<pCount; i++) {
                pos[i*3]=origin.x; pos[i*3+1]=origin.y; pos[i*3+2]=origin.z;
                vels.push(new THREE.Vector3((Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1, (Math.random()-0.5)*0.1));
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({ size: 0.1, color: 0xff69b4, transparent: true });
            const p = new THREE.Points(geo, mat);
            fwGroup.add(p);
            return { p, vels, life: 1.0 };
        }
        let fireworks = [];

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            if (state === "HEART" || state === "EXPLODE") {
                iMesh.rotation.y += 0.005;
            }

            for (let i = 0; i < count; i++) {
                let target;
                if (state === "HEART") {
                    target = targetPositions[i];
                } else if (state === "TEXT") {
                    target = textPts[i % textPts.length];
                } else {
                    // Nổ tung
                    positions[i].multiplyScalar(1.05);
                    target = positions[i];
                }

                positions[i].lerp(target, 0.05);
                dummy.position.copy(positions[i]);
                
                // Hiệu ứng xoay chữ đối xứng
                if (state === "TEXT") {
                    const angle = Math.sin(time) * 0.1;
                    dummy.position.applyAxisAngle(new THREE.Vector3(0,0,1), i < textPts.length/2 ? angle : -angle);
                    iMesh.instanceColor.setAt(i, colors[i].clone().multiplyScalar(0.5));
                } else {
                    // Lấp lánh (sparkle)
                    const s = 0.5 + Math.sin(time * 3 + i) * 0.5;
                    dummy.scale.set(s, s, s);
                    iMesh.setMatrixAt(i, dummy.matrix);
                    iMesh.setColorAt(i, colors[i]);
                }
                
                dummy.lookAt(camera.position); // Các trái tim nhỏ luôn hướng về màn hình
                dummy.updateMatrix();
                iMesh.setMatrixAt(i, dummy.matrix);
            }
            
            iMesh.instanceMatrix.needsUpdate = true;
            if (iMesh.instanceColor) iMesh.instanceColor.needsUpdate = true;

            // Update Fireworks
            if (Math.random() < 0.03) fireworks.push(createFirework());
            fireworks.forEach((f, idx) => {
                const attr = f.p.geometry.attributes.position;
                for(let i=0; i<30; i++) {
                    attr.setXYZ(i, attr.getX(i)+f.vels[i].x, attr.getY(i)+f.vels[i].y, attr.getZ(i)+f.vels[i].z);
                }
                attr.needsUpdate = true;
                f.life -= 0.01; f.p.material.opacity = f.life;
                if(f.life <= 0) { fwGroup.remove(f.p); fireworks.splice(idx, 1); }
            });

            renderer.render(scene, camera);
        }

        // --- INTERACTION ---
        window.addEventListener('pointerdown', () => {
            if (state === "HEART") {
                state = "EXPLODE";
                document.getElementById('overlay').style.opacity = "0";
                setTimeout(() => { state = "TEXT"; }, 1000);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>