<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Love Animation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Great Vibes', cursive; }
        canvas { display: block; touch-action: none; }
        #instruction {
            position: absolute;
            bottom: 20%;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            letter-spacing: 2px;
            opacity: 0.6;
            pointer-events: none;
            font-size: 12px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
</head>
<body>
    <div id="instruction">CHẠM VÀO TRÁI TIM</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CẤU HÌNH CƠ BẢN ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        camera.position.z = 5;

        let state = "HEART"; // HEART -> EXPLODE -> TEXT
        const particlesGroup = new THREE.Group();
        scene.add(particlesGroup);

        // --- TẠO KẾT CẤU TRÁI TIM ---
        const heartPoints = [];
        const particleCount = 4000;
        
        // Hàm tạo hình trái tim 3D (Phương trình parametric)
        function getHeartPoint(t, phi) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            const z = Math.sin(phi) * 8 * Math.pow(Math.sin(t), 2); 
            return new THREE.Vector3(x * 0.1, y * 0.1, z * 0.1);
        }

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        for (let i = 0; i < particleCount; i++) {
            const t = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 2;
            const point = getHeartPoint(t, phi);
            
            // Phân bổ mật độ: Viền đậm hơn, giữa thưa hơn
            const isEdge = Math.random() > 0.4;
            const offset = isEdge ? 1 : 1.5;
            
            positions[i * 3] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 20;

            targetPositions[i * 3] = point.x;
            targetPositions[i * 3 + 1] = point.y;
            targetPositions[i * 3 + 2] = point.z;

            const color = new THREE.Color(i % 2 === 0 ? 0xffb6c1 : 0xffffff);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
            
            sizes[i] = Math.random() * 0.05 + 0.02;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const material = new THREE.PointsMaterial({
            size: 0.04,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const heartPointsMesh = new THREE.Points(geometry, material);
        particlesGroup.add(heartPointsMesh);

        // --- PHÁO HOA TRONG NỀN ---
        const fireworks = [];
        function createFirework() {
            const fwGeo = new THREE.BufferGeometry();
            const count = 100;
            const fwPos = new Float32Array(count * 3);
            const vel = new Float32Array(count * 3);
            const origin = new THREE.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 10, -5);
            
            for(let i=0; i<count; i++) {
                fwPos[i*3] = origin.x; fwPos[i*3+1] = origin.y; fwPos[i*3+2] = origin.z;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const speed = Math.random() * 0.05 + 0.02;
                vel[i*3] = Math.sin(phi) * Math.cos(theta) * speed;
                vel[i*3+1] = Math.sin(phi) * Math.sin(theta) * speed;
                vel[i*3+2] = Math.cos(phi) * speed;
            }
            fwGeo.setAttribute('position', new THREE.BufferAttribute(fwPos, 3));
            const fwMat = new THREE.PointsMaterial({ size: 0.02, color: 0xff69b4, transparent: true });
            const fwMesh = new THREE.Points(fwGeo, fwMat);
            scene.add(fwMesh);
            fireworks.push({ mesh: fwMesh, vel: vel, life: 1.0 });
        }

        // --- XỬ LÝ CHỮ (Canvas Texture) ---
        function createTextMesh() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.font = '70px "Great Vibes"';
            ctx.textAlign = 'center';
            ctx.fillText('Đình Hường <3 Khánh Linh', 512, 256);
            
            // Lấy dữ liệu pixel để tạo hạt cho chữ
            const imgData = ctx.getImageData(0,0,1024,512).data;
            const textCoords = [];
            for(let y=0; y<512; y+=4) {
                for(let x=0; x<1024; x+=4) {
                    if(imgData[(y*1024+x)*4 + 3] > 128) {
                        textCoords.push({
                            x: (x - 512) * 0.01,
                            y: -(y - 256) * 0.01,
                            z: 0
                        });
                    }
                }
            }
            return textCoords;
        }
        const textCoords = createTextMesh();

        // --- ANIMATION LOOP ---
        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getElapsedTime();
            const posAttr = geometry.attributes.position;

            if (state === "HEART") {
                for (let i = 0; i < particleCount; i++) {
                    posAttr.setXYZ(i, 
                        THREE.MathUtils.lerp(posAttr.getX(i), targetPositions[i*3], 0.05),
                        THREE.MathUtils.lerp(posAttr.getY(i), targetPositions[i*3+1], 0.05),
                        THREE.MathUtils.lerp(posAttr.getZ(i), targetPositions[i*3+2], 0.05)
                    );
                }
                particlesGroup.rotation.y += 0.01;
            } else if (state === "TEXT") {
                particlesGroup.rotation.y *= 0.95; // Dừng xoay mạnh
                material.opacity = 0.5;
                
                // Hiệu ứng chữ xoay nhẹ đối xứng
                const time = Date.now() * 0.001;
                const rotZ = Math.sin(time) * 0.1;
                
                for (let i = 0; i < particleCount; i++) {
                    if (i < textCoords.length) {
                        const targetX = textCoords[i].x;
                        const targetY = textCoords[i].y;
                        
                        // Xoay nhẹ các hạt chữ xung quanh tâm
                        const s = Math.sin(rotZ);
                        const c = Math.cos(rotZ);
                        const rx = targetX * c - targetY * s;
                        const ry = targetX * s + targetY * c;

                        posAttr.setXYZ(i, 
                            THREE.MathUtils.lerp(posAttr.getX(i), rx, 0.08),
                            THREE.MathUtils.lerp(posAttr.getY(i), ry, 0.08),
                            THREE.MathUtils.lerp(posAttr.getZ(i), 0, 0.08)
                        );
                    } else {
                        // Các hạt thừa bay tản mác lấp lánh
                        posAttr.setX(i, posAttr.getX(i) + Math.sin(delta + i) * 0.01);
                    }
                }
            }
            
            posAttr.needsUpdate = true;

            // Update Fireworks
            if (Math.random() < 0.05) createFirework();
            fireworks.forEach((fw, index) => {
                const fPos = fw.mesh.geometry.attributes.position;
                for(let i=0; i<100; i++) {
                    fPos.setXYZ(i, fPos.getX(i)+fw.vel[i*3], fPos.getY(i)+fw.vel[i*3+1], fPos.getZ(i)+fw.vel[i*3+2]);
                    fw.vel[i*3+1] -= 0.0005; // Gravity
                }
                fPos.needsUpdate = true;
                fw.life -= 0.01;
                fw.mesh.material.opacity = fw.life;
                if(fw.life <= 0) {
                    scene.remove(fw.mesh);
                    fireworks.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        // --- SỰ KIỆN CLICK ---
        window.addEventListener('pointerdown', () => {
            if (state === "HEART") {
                state = "EXPLODE";
                document.getElementById('instruction').style.display = 'none';
                
                // Tạo hiệu ứng nổ tung trước khi tụ lại thành chữ
                const posAttr = geometry.attributes.position;
                for (let i = 0; i < particleCount; i++) {
                    targetPositions[i*3] *= 5;
                    targetPositions[i*3+1] *= 5;
                    targetPositions[i*3+2] *= 5;
                }
                
                setTimeout(() => {
                    state = "TEXT";
                }, 800);
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>